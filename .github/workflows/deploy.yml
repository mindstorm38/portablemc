name: Deploy

on:
  workflow_dispatch:
  push:
    tags:
      - 'v**'

env:
  CARGO_TERM_COLOR: always
  CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
  GH_TOKEN: ${{ github.token }}

jobs:

  # We always fetch the cargo version, it's used in some places below...
  fetch-version:
    name: Fetch version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
    steps:
      
      - uses: actions/checkout@v4

      - name: Get version
        id: get-version
        shell: bash
        run: echo "version=$(cargo pkgid -p portablemc | awk -F'[#@]' '{print $NF}')" >> $GITHUB_OUTPUT

  # We only check the cargo version if we are running the workflow against a tag.
  # If this tag ends with -test, it is used to test the workflow so we just strip!
  check-version:
    name: Check version against tag
    needs: fetch-version
    if: ${{ startsWith(github.ref, 'refs/tags/') }}
    runs-on: ubuntu-latest
    steps:

      - name: Match cargo version with tag
        shell: bash
        run: test "v${{ needs.fetch-version.outputs.version }}" = $(basename "${{ github.ref_name }}" -test)
  
  # Include the other test workflow but trigger it, including ignored tests!
  # Always running all tests, even if check version is skipped (due to the workflow not
  # being dispatched on a tag).
  # We include ignored test only if the tag is not a test tag
  test-all:
    name: Test all
    needs: check-version
    if: ${{ always() && (needs.check-version.result == 'success' || needs.check-version.result == 'skipped') }}
    uses: ./.github/workflows/test.yml
    with:
      include-ignored: ${{ !startsWith(github.ref, 'refs/tags/') || !endsWith(github.ref, '-test') }}

  # We only build if all test passed.
  build:
    name: Build ${{ matrix.target }} on ${{ matrix.image }}
    needs: test-all
    if: ${{ always() && needs.test-all.result == 'success' }}
    runs-on: ${{ matrix.image }}

    strategy:
      fail-fast: false
      matrix:
        target:
          - x86_64-unknown-linux-gnu
          - i686-unknown-linux-gnu
          - x86_64-apple-darwin
          - aarch64-apple-darwin
          - x86_64-pc-windows-msvc
          - i686-pc-windows-msvc
          - aarch64-unknown-linux-gnu
          - arm-unknown-linux-gnueabihf
        include:
          # ubuntu-24.04 (x86_64)
          - target: x86_64-unknown-linux-gnu
            image: ubuntu-24.04
          - target: i686-unknown-linux-gnu
            image: ubuntu-24.04
            setup: |
              sudo dpkg --add-architecture i386
              sudo apt update
              sudo apt install libssl-dev:i386 gcc-multilib
              echo 'OPENSSL_INCLUDE_DIR=/usr/include' >> $GITHUB_ENV
              echo 'OPENSSL_LIB_DIR=/usr/lib/i386-linux-gnu' >> $GITHUB_ENV
          # macos-15 (x86_64)
          - target: x86_64-apple-darwin
            image: macos-15-intel
          # macos-15 (aarch64)
          - target: aarch64-apple-darwin
            image: macos-15
          # windows-2022 (x86_64)
          - target: x86_64-pc-windows-msvc
            image: windows-2022
          - target: i686-pc-windows-msvc
            image: windows-2022
          # ubuntu-24.04-arm (aarch64)
          - target: aarch64-unknown-linux-gnu
            image: ubuntu-24.04-arm
          - target: arm-unknown-linux-gnueabihf
            image: ubuntu-24.04-arm
            setup: |
              sudo dpkg --add-architecture armhf
              sudo apt update
              sudo apt install libssl-dev:armhf gcc-arm-linux-gnueabihf
              echo 'OPENSSL_INCLUDE_DIR=/usr/include' >> $GITHUB_ENV
              echo 'OPENSSL_LIB_DIR=/usr/lib/arm-linux-gnueabihf' >> $GITHUB_ENV
              echo 'CARGO_TARGET_ARM_UNKNOWN_LINUX_GNUEABIHF_LINKER=/usr/bin/arm-linux-gnueabihf-gcc' >> $GITHUB_ENV

    steps:

      - uses: actions/checkout@v4
      
      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: cargo-registry

      - name: Cache cargo target
        uses: actions/cache@v4
        with:
          path: target
          key: cargo-${{ matrix.image }}-${{ hashFiles('**/Cargo.lock') }}

      - name: Setup
        if: matrix.setup != null
        run: ${{ matrix.setup }}

      - name: Setup rust
        run: rustup target add ${{ matrix.target }}
  
      - name: Dist
        run: cargo xtask dist ${{ matrix.target }}

      - name: Upload workflow artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.target }}
          path: dist/
          if-no-files-found: error
  
  # We only create a release if it's a tag AND if it's not a beta or alpha tag.
  release:
    name: Release
    needs: 
      - fetch-version
      - check-version  # This requires that the workflow is dispatched on a tag!
      - build
    if: ${{ !contains(github.ref, '-beta') && !contains(github.ref, '-alpha') }}
    runs-on: ubuntu-latest
    steps:

      - uses: actions/checkout@v4

      - name: Download workflow artifacts
        id: download-workflow-artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist/
          merge-multiple: true
      
      - name: Debug artifacts
        shell: bash
        run: |
          ls -la dist/

      - name: Setup GPG
        shell: bash
        env:
          GPG_SIGN_KEY: ${{ secrets.GPG_SIGN_KEY }}
        run: |
          echo "$GPG_SIGN_KEY" | gpg --batch --import
          gpg -K --keyid-format long
      
      - name: Sign with GPG
        shell: bash
        run: |
          for archive in dist/*.{tar.gz,zip}; do
            gpg -u "${{ vars.GPG_SIGN_PUB_KEY }}" --detach-sign "$archive"
          done
      
      - name: Prepare release notes
        shell: bash
        run: |
          cp .github/workflows/data/release-notes.md dist/
          for archive in dist/*.tar.gz; do
            archive_basename=$(basename "$archive")
            name=$(basename "$archive_basename" .tar.gz)
            platform=$(tar -axf "$archive" "$name/README" -O | grep '^platform: ' | cut -c 11-)
            archive_url="${{ github.server_url }}/${{ github.repository }}/releases/download/${{ github.ref_name }}/$archive_basename"
            echo "- [$platform]($archive_url) [[sig]($archive_url.sig)]" >> dist/release-notes.md
          done
          for archive in dist/*.zip; do
            archive_basename=$(basename "$archive")
            platform=$(unzip -p "$archive" README | grep '^platform: ' | cut -c 11-)
            archive_url="${{ github.server_url }}/${{ github.repository }}/releases/download/${{ github.ref_name }}/$archive_basename"
            echo "- [$platform]($archive_url) [[sig]($archive_url.sig)]" >> dist/release-notes.md
          done

      - name: Create release
        shell: bash
        run: gh release create ${{ github.ref_name }} --verify-tag --draft --title "Version ${{ needs.fetch-version.outputs.version }}" --notes-file dist/release-notes.md dist/*.{tar.gz,zip,sig}

  # We always publish anyway if the full test + build succeeds.
  # If this tag ends with -test, We don't publish it as we are using it to test workflow.
  publish:
    name: Publish
    needs: build
    if: ${{ !endsWith(github.ref, '-test') }}
    runs-on: ubuntu-24.04
    steps:

      - uses: actions/checkout@v4

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: cargo-registry

      - name: Cache cargo target
        uses: actions/cache@v4
        with:
          path: target
          key: cargo-ubuntu-24.04-${{ hashFiles('**/Cargo.lock') }}

      - name: Publish API
        run: cargo publish --no-verify -p portablemc
      
      - name: Publish CLI
        run: cargo publish --no-verify -p portablemc-cli
