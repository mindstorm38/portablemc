/* automatically generated by rust-bindgen 0.71.1 */

#[doc = " An array of 16 bytes representing an UUID."]
pub type pmc_uuid = [u8; 16usize];
#[repr(i32)]
#[doc = " The code of an error that can be retrieved via"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pmc_err_tag {
    PMC_ERR_UNSET = 0,
    PMC_ERR_INTERNAL = 1,
    PMC_ERR_MSA_AUTH_DECLINED = 16,
    PMC_ERR_MSA_AUTH_TIMED_OUT = 17,
    PMC_ERR_MSA_AUTH_OUTDATED_TOKEN = 18,
    PMC_ERR_MSA_AUTH_DOES_NOT_OWN_GAME = 19,
    PMC_ERR_MSA_AUTH_INVALID_STATUS = 20,
    PMC_ERR_MSA_AUTH_UNKNOWN = 21,
    PMC_ERR_MSA_DATABASE_IO = 32,
    PMC_ERR_MSA_DATABASE_CORRUPTED = 33,
    PMC_ERR_MSA_DATABASE_WRITE_FAILED = 34,
    PMC_ERR_STANDARD_HIERARCHY_LOOP = 48,
    PMC_ERR_STANDARD_VERSION_NOT_FOUND = 49,
    PMC_ERR_STANDARD_ASSETS_NOT_FOUND = 50,
    PMC_ERR_STANDARD_CLIENT_NOT_FOUND = 51,
    PMC_ERR_STANDARD_LIBRARY_NOT_FOUND = 52,
    PMC_ERR_STANDARD_JVM_NOT_FOUND = 53,
    PMC_ERR_STANDARD_MAIN_CLASS_NOT_FOUND = 54,
    PMC_ERR_STANDARD_DOWNLOAD_RESOURCES_CANCELLED = 55,
    PMC_ERR_STANDARD_DOWNLOAD = 56,
}
#[doc = " PMC_ERR_INTERNAL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_err_data_internal {
    pub origin: *const ::std::ffi::c_char,
}
#[doc = " PMC_ERR_MSA_AUTH_INVALID_STATUS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_err_data_msa_auth_invalid_status {
    pub status: u16,
}
#[doc = " PMC_ERR_MSA_AUTH_UNKNOWN"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_err_data_msa_auth_unknown {
    pub message: *const ::std::ffi::c_char,
}
#[doc = " PMC_ERR_STANDARD_HIERARCHY_LOOP"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_err_std_hierarchy_loop {
    pub version: *const ::std::ffi::c_char,
}
#[doc = " PMC_ERR_STANDARD_VERSION_NOT_FOUND"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_err_std_version_not_found {
    pub version: *const ::std::ffi::c_char,
}
#[doc = " PMC_ERR_STANDARD_ASSETS_NOT_FOUND"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_err_std_assets_not_found {
    pub id: *const ::std::ffi::c_char,
}
#[doc = " PMC_ERR_STANDARD_JVM_NOT_FOUND"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_err_std_jvm_not_found {
    pub major_version: u32,
}
#[doc = " The union of all data types for errors."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmc_err_data {
    pub _none: ::std::ffi::c_int,
    pub internal: pmc_err_data_internal,
    pub msa_auth_invalid_status: pmc_err_data_msa_auth_invalid_status,
    pub msa_auth_unknown: pmc_err_data_msa_auth_unknown,
    pub std_hierarchy_loop: pmc_err_std_hierarchy_loop,
    pub std_version_not_found: pmc_err_std_version_not_found,
    pub std_assets_not_found: pmc_err_std_assets_not_found,
    pub std_jvm_not_found: pmc_err_std_jvm_not_found,
}
#[doc = " Generic error type, you should usually use this type by defining a null-pointer to it\n and passing a pointer to that pointer to any function that accepts it. If an error\n happens, the function will allocate an error and then write its pointer in the given\n location. The error should be freed afterward.\n\n This structure has a known layout in C."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmc_err {
    #[doc = " Tag of the error."]
    pub tag: pmc_err_tag,
    #[doc = " The data of the tag, that can be used depending on the error tag."]
    pub data: pmc_err_data,
    #[doc = " The descriptive human-readable message for the error."]
    pub message: *const ::std::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_msa_auth {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_msa_device_code_flow {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_msa_account {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_msa_database {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_game {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_standard {
    _unused: [u8; 0],
}
#[doc = " The installer that supports the minimal standard format for version metadata with\n support for libraries, assets and loggers automatic installation. By defaults, it\n also supports finding a suitable JVM for running the game."]
pub type pmc_base = pmc_standard;
#[repr(i32)]
#[doc = " The tag for the pmc_jvm_policy tagged union."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pmc_jvm_policy_tag {
    PMC_JVM_POLICY_STATIC = 0,
    PMC_JVM_POLICY_SYSTEM = 1,
    PMC_JVM_POLICY_MOJANG = 2,
    PMC_JVM_POLICY_SYSTEM_THEN_MOJANG = 3,
    PMC_JVM_POLICY_MOJANG_THEN_SYSTEM = 4,
}
#[doc = " The JVM policy tagged union, only the static policy requires an explicit path value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_jvm_policy {
    pub tag: pmc_jvm_policy_tag,
    pub static_path: *const ::std::ffi::c_char,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pmc_version_channel {
    PMC_VERSION_CHANNEL_RELEASE = 0,
    PMC_VERSION_CHANNEL_SNAPSHOT = 1,
    PMC_VERSION_CHANNEL_BETA = 2,
    PMC_VERSION_CHANNEL_ALPHA = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmc_loaded_version {
    pub name: *const ::std::ffi::c_char,
    pub dir: *const ::std::ffi::c_char,
    pub channel: pmc_version_channel,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum pmc_standard_event_tag {
    PMC_EVENT_FILTER_FEATURES = 0,
    PMC_EVENT_LOADED_FEATURES = 1,
    PMC_EVENT_LOAD_HIERARCHY = 2,
    PMC_EVENT_LOADED_HIERARCHY = 3,
    PMC_EVENT_LOAD_VERSION = 4,
    PMC_EVENT_NEED_VERSION = 5,
    PMC_EVENT_LOADED_VERSION = 6,
    PMC_EVENT_LOAD_CLIENT = 7,
    PMC_EVENT_LOADED_CLIENT = 8,
    PMC_EVENT_LOAD_LIBRARIES = 9,
    PMC_EVENT_FILTER_LIBRARIES = 10,
    PMC_EVENT_LOADED_LIBRARIES = 11,
    PMC_EVENT_FILTER_LIBRARIES_FILES = 12,
    PMC_EVENT_LOADED_LIBRARIES_FILES = 13,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pmc_standard_event_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pmc_standard_event {
    pub tag: pmc_standard_event_tag,
    pub data: pmc_standard_event_data,
}
pub type pmc_standard_handler =
    ::std::option::Option<unsafe extern "C" fn(event: *const pmc_standard_event)>;
